# Data-Structures-Algorithms
Data-Structures-Algorithms
002.玩转数据结构
	概述
		数据结构
			数据结构研究的是数据如何在计算机中进行组织和存储，使得我们可以高效的获取数据或者修改数据
		数据结构分类
			线性结构
				数组
				栈
				队列
				链表
				哈希表
			树结构
				二叉树
				二分搜索树
				AVL
				红黑树
				Treap
				Splay
				堆
				Trie
				线段树
				K-D树
				并查集
				哈夫曼树
			图结构
				邻接矩阵
				邻接表
		数据库
			数据库就是一个已经封装好的软件，只需要使用sql的语言使用数据库就好了，
			创造数据库需要大量数据结构的支持
				树结构
					AVL、红黑树、Treap、伸展树、B树
				哈希表
		操作系统-多任务切换
			系统栈
			优先队列：堆
		文件压缩
			哈夫曼树
		通讯录
			链表-线性结构
				当通讯录联系人非常多，查找一个联系人非常慢
				当时手持设备的计算速度和计算性能非常低
			Trie-前缀树
				毫秒级别的查询
		大量算法以数据结构为基石
			寻路算法
				图论算法
				DFS:使用栈，深度优先遍历
				BFS:使用队列，广度优先遍历
		程序 = 数据结构 + 算法
	介绍
		十二种数据结构
			数组、栈、队列、链表
			二分搜索树、堆、线段树、Trie
			并查集、AVL、红黑树、哈希表
		脚本语言的特殊性
			如JS、Python等
			个人认为：脚本语言可以用来学习数据结构的原理；但是不适于考察数据结构(和算法)的性能
			对于脚本语言来说，写出来的逻辑性能怎样，不仅仅和逻辑相关，还非常依赖于脚本语言的解析器，对不同的写法，解析的不同
			对于Python来讲，Pythonic写法可能比逻辑本身更重要
		lesson
			C++算法与数据结构
				各种排序算法的比较
				快速排序;堆排序
				图算法
				图示
					
			玩转数据结构
				以数据结构为主线
			玩转算法面试leetcode
				算法设计领域的问题
		question
			bad question
				直接贴代码，问：这个代码为什么输出结果不对
			good question
				详细说明，具体在哪个地方出了问题?你的思考是怎样的？认为会得到怎么样的结果？可实际却得到了怎样的输出？
		竞赛
			竞赛涵盖的内容更广泛，深度也更高。
			图论、计算几何、组合数学、概率、更复杂的算法和数据结构
		子主题 6
	数组
		数组
			把数据码成一排进行存放
			数组基础
				数组优点：快速查询。scores[2]
				数组最好应用于“索引有语意”的情况
				但并非所有有语意的索引都适用于数组，例如身份证太大，开辟的空间太大或证号有误，无效
				数组也可以处理“索引没有语意的情况”，数值太大或无效浪费
			只要处理
				主要处理“索引没有语意”的情况数组的使用。
				索引没有语意，如何表示没有元素
				如何添加元素？如何删除元素？....
				基于java的数组，二次封装自己的数组类
			制作数组类
				增删改查
				操作数据库涉及增删改查工作，数据结构本质和数据库是一样的，也是存储数据，之后再高效的对数据进行操作，只不过设计的数据结构会把数据存储再内存中，所以针对数据结构添加的操作，在大的类别的划分上，也是增删改查
				不同数据结构，增删改查的方式是截然不同的，有些数据结构会忽略这四个动作中的某一个动作，
			泛型
				能存放任意类型的数据
				不可以是基本数据类型，只能是类对象
				java中的8种基本数据类型
					boolean
					byte
					char
					short
					int
					long
					double
				每个基本数据类型都有对应的包装类——autoFixing
					Boolean、Byte、Char、Short、Int、Long、Float、Double
				== 和 equals：引用比较和值比较
				loitering objects != memory leak:
		复杂度分析
			简单的时间复杂度分析
				O(1)、O(n)、O(nlogn)、O(n^2)
				大O描述的是算法的运行时间和输入数据之间的关系
				O(n)：n是nums中的元素个数，算法运行时间的多少是和nums中元素的个数呈线性关系的，
线性关系表现在n是一次方
				为什么要用大O，叫做O(n)
					忽略常数。实际时间 T = C1*n + C2
					渐进时间复杂度，描述趋近于无穷的情况
					处理n中的每一个数据花费的总时间是C1，运行前开内存空间还要把结果return回去，这个时间叫C2
					具体分析算法的时候，如果把c1 和 c2是多少具体分析出来，一方面必要性不大，另一方面有些情况下是不可能的；不同语言基于不同实现，实际运行的时间不等，转换成字节码对应的指令树也可能不同；同一个指令在不同的CPU执行的时间也不一样
				O(n)不代表在任意输入的时候快过O(n^2)
					图示
						
				动态数组的时间复杂度分析
					
					
					
					
					增删改查的时间复杂度
			均摊复杂度
				resize操作不可能在每次addLast的时候，都触发；2n+1/n+1
				平均，每次addLast操作，进行2次基本操作
				这样均摊计算，时间复杂度是O(1)的；在这个例子里面，这样均摊计算比计算最坏情况有意义
				同理，我们看removeLast操作，均摊复杂度也为O(1)
				工程意义
					一个相对比较耗时的操作，如果能保证不被每次都触发的话，那么这个相对比较耗时的操作的时间可以相应的分摊到其他的操作中来的
				图示
					
			防止复杂度的震荡
				存在每一次都会耗费O(n)复杂度的情形
				出问题的原因: removeLast时 resize 过于急着(Eager)
				解决方案：Lazy
					当size = capacity /4 时，才将capacity减半
				图示
					复杂度震荡
					Lazy
					Lazy
	leetcode注意事项
		完美主义害死人
		有收获最重要
		不是一个教程看一遍就是这个领域的专家大牛了
		学习方法讨论
			不要完美主义。掌握好‘度’
			学习本着自己的目标去
			子主题 3
	线性数据结构
		栈-Stack
			栈
				栈也是一种线性结构
				相比数组，栈对应的操作是数组的子集，操作更少
				只能从一端添加元素，也只能从一端取出元素
				这一端称为栈顶
			特点
				栈是一种后进先出的数据结构
				Last In First Out(LIFO)
				在计算机的世界里，栈拥有不可思议的作用
			栈的应用
				Undo操作(撤销)-编辑器
				程序调用的系统栈-操作系统
					从一个逻辑终止，跳到另外一个逻辑去执行，即自函数的调用
					子过程子逻辑的调用，在编译器内部运行实现的基理
					使用一个系统栈一样的数据结构，来记录程序的调用过程
					图示
						系统栈的调用
				括号匹配-编译器
			栈的实现
				push(E): 入栈
				E pop：出栈
				E peek：查看栈顶元素
				int getSize：查看栈内元素
				boolean isEmpty：是否为空
				图示
					栈的实现
					基于多态性实现栈
			栈的复杂度分析
				
			栈的应用
				括号匹配
					栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素
		动态数组
		队列-Queue
			队列
				队列也是一种线性结构
				相比数组，队列对应的操作是数组的子集
				只能从一端(队尾)添加元素，只能从另一端(队首)取出元素
			特点
				队列是一种先进先出的数据结构(先到先得)
				First In First Out(FIFO)
			队列的实现
				
			数组队列的复杂度分析
				
				数组队列的局限性：出队的操作，时间复杂度是O(n)级别
				删除队首的时候，其他元素都要前移一位
			循环队列
				子主题 1
				图示
					循环队列初始的队首和队尾，
front == tail 队列为空
					浪费一个空间，区别队满与队列空
				循环队列的复杂度
					
			数组队列和循环队列的比较
				10w数据的入队和出队操作时间差别
					
				差距主要在出队的过程中
		链表-Linked List
			链表特点
				真正的动态数据结构
				最简单的动态数据结构
				更深入的理解引用(或者指针)
				更深入的理解递归
				辅助组成其他数据结构
			链表
				数据存储在“节点”(Node)中, 包括当前节点数据和下一节点的地址
					class Node{
	E e;
	Node next;
}
				最后一个节点的 next 是 null
				优点
					真正的动态，不需要处理固定容量的问题
			链表的特点
				优点
					真正的动态，不需要处理固定容量的问题
				缺点
					丧失了随机访问的能力
			链表结构图示
				
				链表头添加数据方便，链表尾添加数据不方便
				插入元素，关键找到添加节点的前一个节点
				链表操作的顺序很重要
				链表的删除，让待删除节点的前一个节点的next变化，
而不是待删除节点的Node变量变化，
函数结束，Node块作用域也就失效了
Node消失，而整个链表没有发生变化
			数组和链表的对比
				数组
					数组最好用于索引有语意的情况。score[2]
					最大的优点：支持快速查询
				链表
					链表不适合用于索引有语意的情况
					最大的优点：动态
			链表的时间复杂度分析
				图示
					添加操作的时间复杂度O(n)
					删除操作的时间复杂度O(n)
					修改操作的时间复杂度O(n)
					查找操作的时间复杂度O(n)
					链表整体的时间复杂度
				链表的增删改查4个操作，时间复杂度全都是O(n)级别的，整体的时间复杂度比数组要差，
				对于数组来说，如果有索引的话，可以快速的访问，链表不能
				对于链表来说，如果只对链表头进行操作是O(1)，链表适合不修改，不查任意元素，只查链表头这样的元素，在增加删除的时候只对链表头进行操作，这个时候时间复杂度整体是和数组一样的，因为总体是动态的，所以不会浪费大量的内存空间，具有一定的优势
				适合栈的数据结构，每次都只操作表头元素
			使用链表实现栈
				子主题 1
				链表栈与数组栈运行时间比较
					
					测试数据越大链表需要的时间越长
				图示
					
			链表丝线队列
				子主题 1
				同时队列实现的时间比较
					
				图示
					链表队列图示
		链表和递归
			递归一般和树连接在一起，因为链表是线性的，比较简单，一般使用循环就能解决问题
			删除链表中的元素
			递归
				递归
					本质上，将原来的问题，转化为更小的统一问题
					递归函数的宏观语义
						求解最基本的问题
						把原问题转化为更小的问题
					递归就是一个函数，完成一个功能
					递归调用是有代价的：函数调用 + 系统栈空间
十万级别的调用会出问题
					非线性结构使用递归，使逻辑更加简单
					递归函数的微观解读
						图示
							
							
							
				举例
					数组求和
						Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])
						Sum(arr[1...n-1]) = arr[1] + Sum(arr[1...n-1])
			更多链表相关问题
				关于递归的宏观和微观
				近乎和链表相关的所有操作，都可以使用递归的形式完成
				建议对链表的增、删、改、查，进行递归实现
				链表的种类
					双向链表
					循环双向链表，不在需要tail
					数组链表
		链表和数组的区别
			动态数组、栈、队列，底层依托静态数组，靠resize解决固定容量的问题
			链表是真正的动态数据结构
	树形数据结构
		为什么使用树结构
			将数据使用树结构存储后，出奇的高效
			树的类型
				二分搜索树(Binary Search Tree)
				平衡二叉树： AVL 红黑树
				堆 并查集
				线段树 Trie(字典树 前缀树)
		二分搜索树-Binary Search Tree
			二分搜索树也是一个动态的数据结构，也是靠节点挂接起来的，
只是这些节点没排成一根线，排成了一棵树，每个节点有指向左子树和右子树的根节点
			二叉树
				和链表一样，动态数据结构
				二叉树(多个叉的时候，多叉树)
				二叉树具有唯一根节点
				二叉树每个节点最多有俩个孩子
				二叉树不一定是满的
				一个节点也是二叉树
				空也是二叉树(链表头节点为NUll的时候也是一个链表)
				示例
					class Node{
	E e;
	Node left;
	Node right;
}
			二分搜索树
				二分搜索树是二叉树
				二分搜索树的每个节点的值
					大于其左子树的所有节点的值
					小于其右子树的所有节点的值
				每一颗子树也是二分搜索树
				存储元素的必须有可比较性(能比大小)
					这是二分树的局限性，数组/链表无此要求
				图示
					
			二分搜索树的实现
				实现的二分搜索树不包含重复元素
					如果想包含重复的元素，只需要定义：
左子树小于等于节点; 或者右子树大于等于节点
					注意：数组和链表，可以有重复元素
				二分搜索树添加元素的非递归写法，和链表很像
			二叉树的遍历
				遍历方式
					前序遍历
						
					中序遍历：排序遍历
						中序遍历，就是排序后的结果
					后序遍历：为二分搜索树释放内存
先释放孩子节点，再处理节点本身
						针对孩子节点求解出答案，最终再用答案组合成针对这个节点的答案，
树形问题：分治算法、回溯算法、动态规划算法等等
				二分搜索树前序遍历的非递归写法
					二分搜索树遍历的非递归实现，比递归实现复杂很多
					中序遍历和后序遍历的非递归实现更复杂
					中序遍历和后序遍历的非递归实现，实际应用不广
					图示
						
				二分搜索树的层序遍历(广度优先)
					使用队列，对根节点进行遍历
					广度优先遍历的意义
						可以更快的找到你想查询的元素，更快找到问题的解
						常用于算法设计中 - 最短路径(无权图)
						图中的深度优先遍历和广度优先遍历
						主要用于搜索策略，而不是用于遍历的操作上
					图示
						二分搜索树使用队列的层序遍历
				删除二分搜索树的最小值和最大值
					最小值向左走，最大值向右走
					图示
						
						删除最小值
							
							
						删除最大值
							
							
				删除二分搜索树的任意节点
					删除的节点只有左孩子，将左孩子取代其位置
					删除的节点只有又孩子，将右孩子取代其位置
					删除左右都有孩子的节点
						删除之后，不能简单的直接用左子树或者右子树代替它，需要将左右子树融合起来
						需要找一个节点替代它的位置，左右子树中离58最近，比58大的节点
						即右子树中对应的最小值的节点值
						删除右子树中最小值的节点，将右子树最小值的节点替换删除的节点
						也可以找左子树的最大值取代
					Hibbard Deletion
						子主题 1
					图示
						删除的节点只有左孩子
							
							
						删除只有右孩子的节点
							
							
						删除任意节点
							
							
							
							
				特点
					二叉树的每个节点在采用递归调用的时候，会访问它三次：
遍历左子树之前、遍历完左子树回到当前节点、遍历完右子树后回到节点
						不同遍历方式的访问时机
						前序遍历
						中序遍历图示
						后序遍历
					二分搜索树的顺序性
						minimun
						maximum
						successor-后继
						predecessor-前驱
						floor和ceil
							子主题 1
							
						rank
							对于二分搜索树中所有的元素，给出一个元素，问排名是第几
						select
							排名是第十名的元素是谁？
							维护一个size，存储节点个数
							维护depth的二分搜索树
					支持重复元素的二分搜索树
						左子树 <=， 右子树 >
						图示
							
							使用count变量维护重复元素的个数
		集合和映射-Set and Map
			相对高层的数据结构，像栈和队列，定义了数据结构相应的使用接口，有了使用的接口包括这些数据结构本身所维持的一些性质，就可以非常容易的将他们放到一些应用中，但是具体的底层实现可以是多种多样的，栈和队列的底层实现既可以是动态数组，又可以是链表...
			集合-Set
				特点
					承载元素的一个容器
					集合的特点，每个元素只能存在一次
					可以非常快速的去重
				集合的设计
					Set <E>
void add(E)
void remove(E)
boolean contains(E)
int getSize()
boolean isEmpty()
				典型应用
					客户统计
					词汇量统计
				集合的实现
					二分搜索树
						不能重复盛放重复元素
						非好好的实现“集合”的底层数据结构
					链表
						BST和LinkedList都属于动态数据结构
							BTS
class Node{
	E e;
	Node left;
	Node right;
}
							LinkedList
class Node{
	E e;
	Node next;
}
				不同集合实现的时间复杂度
					二分搜索树与链表集合的时间复杂度区别
						
						
						
						
						退化成链表的二分树，此种情况的二分搜索树和链表无异
						解决最坏的情况，使用平衡二叉树
					二分搜索树集合和链表集合操作的时间复杂度
						增加的时候，链表因为要先判断元素是否存在，所以时间复杂度是O(n)
						二分搜索树的操作复杂度和其层级有关，即二分树的高度
						二分搜索树高度h和节点数量n的关系
							子主题 1
							图示
								层级与节点数的关系
								满二叉树的节点个数
								满二叉树节点和层级之间的关系
				有序集合和无序集合
					有序集合
						有序集合中的元素具有顺序性
						基于二分搜索树和java标准库基于红黑树实现的集合，本质都是有序的集合
					无序集合
						无序集合中的元素没有顺序性
						基于链表实现的集合是无序集合
						无序集合更好的实现方案--哈希表
					一些问题中集合的有序性非常重要，在另一些问题中没必要使用有序集合，比如：唯一莫斯码
					图示
						
				多重集合
					集合中的元素可以重复
					允许重复元素的二分搜索树
			映射-Map
				映射
					像函数，函数可以理解为一种映射
					存储(键，值)，数据对的数据结构(Key，Value)
					根据键(Key)，寻找值(Value)
					字典-dict
						对于每个单词，有对应的示意
						类似 -名册，身份证号对应的人
						车辆管理，车牌号对应车
						数据库，id-->账号
						词频统计，单词--> 频率
						图示
							
				使用链表或者二分搜索树实现
					映射的接口定义
						Map<K, V>
void add(K, V)
V remove(K)
boolean contains(K)
V get(K)
void set(K, V)
int getSize()
boolean isEmpty()
					图示
						链表和二分树的结构
						使用链表或二分搜索树实现的结构
				映射的时间复杂度分析
					链表和二分树映射的测试执行时间
						
					映射的时间复杂度分析
						
				映射其他
					有序映射和无序映射
						有序映射中的键具有顺序性-基于搜索树的实现
						无序映射中的键没有顺序行-基于哈希表的实现
					多重映射
						多重映射
							多重映射中的键可以重复
					集合和映射
						都可以使用链表和二分搜索树实现
						对于映射来说，本身也是一个键K的集合，每一个Key携带了一个value而已
						可以根据映射，直接包装出集合的结构，集合相当于value是null的映射
						图示
							
		堆和优先队列
			堆
				使用堆作为优先队列的底层实现
				堆的基本结构
					二叉堆
						使用二叉树表示的堆
						二叉堆是一个完全二叉树，不一定是一个满的二叉树，但是这个树缺失的部分肯定是在这棵树的右下侧
						最大堆：堆中某个节点的值总是不大于其父节点的值，所有节点 >= 孩子节点
	此时根节点肯定是最大的元素
							层次比较低的节点的值，不一定大于层次比较高的节点
						二叉堆：只保证每一个节点的父亲节点比自己大，节点的大小和节点的层级无关
						完全二叉树相当于节点按顺序一层一层的码放出来，可以使用数组来表示完全二叉树
						图示
							二叉堆
							完全二叉树
							二叉堆的性质：
	# 层次低的节点比一定小于层次高的节点
							使用数组存储二叉堆： 如何找到左右孩子
							数组从0开始存储的二叉堆： 左右孩子计算公司偏移
					二叉树
						满二叉树：除了叶子节点，所有节点左右孩子都不为空
						完全二叉树：不一定是一个满的二叉树，缺失的节点一定是整颗树的右下侧
	每一层都是从左到右盛放节点
				堆中添加元素和Shift Up
					对添加的节点，可能比父亲节点大，依次与其父亲节点比较，交换到正确的位置
					图示
						添加节点
						与父亲节点比较交换
						依次比较父亲节点
				取出堆中最大元素-Shift Down
					子主题 1
					图示
						最大堆，就是取出堆顶元素
						将最后一个元素顶到堆顶
						堆顶的下沉
							
							
							
						然后进行数据下沉，比较的元素与其俩个孩子进行比较，和孩子中最大的元素交换位置
				replace
					replace：取出最大元素后，放入一个新元素
					实现：可以先extractMax，再add，俩次O(logn)的操作
					实现：可以直接将堆顶元素替换以后Shift Down， 一次O(logn)的操作
				heapify
					heapfy：将任意数组整理成堆的形状
					直接把一个数组看成是完全二叉树，从最后一个叶子节点开始进行 shif Down
					最后一个节点的父亲节点，就是最后一个非叶子节点——(index-1)/2
					近乎少操作的一半的节点(叶子节点)，对另一半的节点(非叶子节点) 进行shift Down的操作
					Heapify的算法复杂度
						将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)
						heapify的过程，算法复杂度为O(n)
						Heapify和从空堆中一个一个添加元素的时间复杂度的比较
							时间减少小一倍
					图示
						找到最后一个非叶子节点
						进行下沉操作
						然后一次对其他非叶子节点进行下沉操作
						依次下层操作完所有非叶子节点
				堆的时间复杂度分析
					子主题 1
					图示
						
			优先队列
				优先队列
					普通队列：先进先出，后进后出
					优先队列：出队顺序和入队顺序无关；和优先级有关
					优先队列和普通队列的区别，主要在出队和队首元素的设置上：
	出队元素是优先级最高的元素，队首元素也是优先级最高的元素，不是最早进入队列的元素
				应用
					操作系统中任务的调度，优先分配CPU的时间片，动态选择(任务是不断变化的)优先级最高的执行
					即时战略的，自动攻击/采集任务
				优先队列接口设计
					队列接口
						Interface Queue<E>
void enqueue(E)
E dequeue()
E getFront() 
int getSize()
boolean isEmpty()
					图示
						
				基于最大堆的优先队列
					使用最大堆的接口实现优先队列
				优先队列经典问题
					在1000000个元素中选出前100名？——在N个元素中选出前M个元素
						排序，NlogN
						使用优先队列
							使用优先对列，NlogM
							使用优先队列，维护当前看到的前M个元素
							使用最小堆，直接替换最小的元素
						Map也可以实现，TreeMap
						java的PriporityQueue：使用的是最小堆
				不同底层优先队列的复杂度比较
					不同底层实现的复杂度比较
					普通线性结构，不能直接在出队的时候找到最大元素，需要扫描一下
					顺序线性结构，所有数据都一直维持一个线性，
出队将变得很容易，只需要拿出线性结构队首或者队尾的元素
入队的时候，需要找到当前元素需要插入到线性结构的什么位置，需要扫描一遍

					堆数据结构
入队和出队俩个动作都可以做到是O(logn)
			堆其他相关
				d叉堆-d-ary-heap
					
					有d个孩子的树，这样的堆层数更低，入队和出队相应的时间复杂度O((logd)N)
				索引堆
					需要看到堆中间的元素，并且可以对堆中间的元素进行修改
					图论的最小生成树和最短路径算法，都可以使用索引堆进行优化
				二项堆
				斐波那契堆
			广义队列
				只要支持入队操作和出队操作，它就可以认为是一个队列
				普通队列、优先队列
				栈，也可以理解成是一个队列(pop,push)
				深度实战--看得见的算法，随即迷宫生成
		线段树(区间树)-Segment Tree
			为什么使用线段树
				有一类问题，我们关心的是线段(或者区间)
				对于给定区间：
更新：更新区间中一个元素或者一个区间的值
查询一个区间[i，j]的最大值，最小值或者区间数字
				图示
					
				经典的线段树问题：区间染色
					有一面墙，长度为n，每次选择一段儿墙进行染色，每次可能会覆盖之前的颜色
m次操作后，可以看见多少种颜色
m次操作后，可以在[i，j]区间内看见多少种颜色
					图示
						线段树的题目应用
				区间查询
					2017注册用户中消费最高的用户？消费最少的用户？学习时间最长的用户？
					某个太空区间的天体总量？
			线段树
				线段树
					树的每个节点，表示的是某一个区间的信息
					线段树不一定是满二叉树，也不一定是完全二叉树(只缺右)
					线段树是平衡二叉树，堆也是平衡二叉树，二分搜索树不是平衡二叉树
					线段树是平衡二叉树，依然可以用数组表示
可以将其看为满二叉树，将不存在的节点看成是空就好了
				区间有n个元素 数组表示需要多少个节点
					满二叉树的节点数
						h层，一共有2^h - 1个节点(大约是2^h)
						最后一层(h-1层)，有2^(h-1)个节点
						最后一层的节点数大致等于前面所有层节点之和
					区间节点数
						n个元素，数组表示需要4n空间
						线段树不考虑添加元素，即区间固定，使用4n的静态空间即可
				平衡二叉树
					对整颗树来说，最大的深度和最小的深度，他们之间的差，最多只有可能为1
					平衡二叉树不会像二分搜索树一样，退化成一个链表
					平衡二叉树和它的节点之间的关系，一定一个logn之间的关系
				以求和为列
					每个树节点存储的一段区间的数字和，根节点存储的是整个线段整个节点存储的数字和
					层层下分，之后最后的叶子节点都只存一个元素(也是一个区间，只不过长度是1)
					图示
						
				n个元素需要有多少节点
				图示
					非满二叉树的平衡二叉树
					区间有n个元素，需要有多少个节点
			线段不同底层实现的时间复杂度
				